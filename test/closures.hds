import libc as c;

def main(): Void {
    val capture = b"capture";
    val print_str = |str: *Byte|: *Byte {
        c.puts(capture);
        c.puts(b"printing string");
        c.puts(str);
        return b"result";
    };

    val result = print_both_and_return_second[Bool, *Byte, *Byte](true, b"hello", |b| {
        c.puts(capture);
        c.puts(b"printing boolean");
        if b {
            c.puts(b"true");
        } else {
            c.puts(b"false");
        }
    }, print_str);

    c.puts(b"closure application returned value");
    c.puts(result);

    val capture1 = true;
    c.puts(apply(true, |value| if (value) b"true" else b"false"));
    // struct Ctx$1 {
    //   val capture1: Bool;
    // }
    // def fp$1(value: Bool, ctx: *f$s): *Byte {
    //    return if (value and ctx.capture1) b"true" else b"false";
    // }
    // val ctx$1 = Ctx$1(capture1);
    // val closure1 = Closure[*Byte](
    //   pointer_cast[Void](&ctx$1),
    //   pointer_cast[() -> *Byte](fp$1)
    // )
    //
    c.puts(apply(false, |value| if (value and capture1) b"true" else b"false"));
}

extern def f(): Void = f;

def print_both_and_return_second[T1, T2, T2R](first: T1, second: T2, print_first: (T1) -> Void, print_second: (T2) -> T2R): T2R {
    print_first(first);
    return print_second(second);
}

// struct Closure[Result] {
//   val ctx: *Void;
//   val fp: *() -> Result;
// }
def apply[T, U](value: T, fn: (T) -> U): U {
    return fn(value);
}

// def apply[T, U](value: T, fn: Closure[U]): U {
//   val fp = pointer_cast[(T, *Void) -> U](fn.fp);
//   return fp(tmp$1, fn.ctx);
// }
