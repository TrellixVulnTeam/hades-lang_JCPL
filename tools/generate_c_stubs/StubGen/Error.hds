import libc as c;
import libc.errno as Errno;
import hades.UnsafeCast as UnsafeCast;
import StubGen.Flags as SGFlags;
import Clang as Clang;
import hades.Assert as Assert;
import hades.Debug as Debug;

type t = Self;

type Kind = Int;
type _Data = union[Bool, SGFlags.ParseError, Clang.CXErrorCode, Errno.t];

const KIND_UNIMPLEMENTED: Kind = 0;
const KIND_INVALID_FLAGS: Kind = 1;
const KIND_CLANG_ERROR: Kind = 2;
const KIND_ERRNO: Kind = 3;

struct Self {
    val m_kind: Kind;
    val m_data: _Data;
}

def unimplemented(): Self {
    return Self(KIND_UNIMPLEMENTED, UnsafeCast.upcast(false));
}

def invalid_flags(error: SGFlags.ParseError): Self {
    return Self(KIND_INVALID_FLAGS, UnsafeCast.upcast(error));
}

def clang_error(error: Clang.CXErrorCode): Self {
    Assert.assert(error != Clang.CXError_Success);
    return Self(KIND_CLANG_ERROR, UnsafeCast.upcast(error));
}

def errno(error: Errno.t): Self {
    return Self(KIND_ERRNO, UnsafeCast.upcast(error));
}

def is(self: Self, k: Kind): Bool {
    return kind(self) == k;
}

def kind(self: Self): Kind {
    return self.m_kind;
}

def _data[T](self: Self): T {
    return UnsafeCast.downcast(self.m_data);
}

def dump(self: Self): Void {
    if is(self, KIND_UNIMPLEMENTED) {
        c.puts(b"UNIMPLEMENTED");
    }

    if is(self, KIND_INVALID_FLAGS) {
        c.puts(_data[SGFlags.ParseError](self).message);
        c.puts(SGFlags.USAGE);
    }

    if is(self, KIND_CLANG_ERROR) {
        Clang.dump_error_code(_data[Clang.CXErrorCode](self));
    }

    if is(self, KIND_ERRNO) {
        c.puts(_data[Errno.t](self) |> Errno.description);
    }
}
