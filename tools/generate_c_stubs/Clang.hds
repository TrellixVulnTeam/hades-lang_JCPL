import hades.Debug as Debug;

type Index = *mut Void;

struct TranslationUnitImpl {}
type MutTranslationUnit = *mut TranslationUnitImpl;
type TranslationUnit = *TranslationUnitImpl;

/// @param exclude_declarations_from_pch: Bool
/// @param display_diagnostics: Bool
extern def create_index(Bool, Bool): Index = clang_createIndex;

extern def dispose_index(Index): Void = clang_disposeIndex;

struct UnsavedFile {
  // The file whose contents have not yet been saved.
  // This file must already exist in the file system.
  val filename: *Byte;

  // A buffer containing the unsaved contents of this file.
  //
  val contents: *Byte;

  // The length of the unsaved contents of this buffer.
  val length: Int; // actually a Long; TODO: Fix this when support for proper int sizes is added
}

extern def parse_translation_unit_2(
    Index,
    *Byte, // source filename
    **Byte, // command line args
    Int, // num_command_line_args,
    *UnsavedFile, // unsaved_files,
    Int, // num_unsaved_files,
    Int, // options,
    *mut TranslationUnit // result
): CXErrorCode  = clang_parseTranslationUnit2;

extern def parse_translation_unit(
    Index,
    *Byte, // source filename
    **Byte, // command line args
    Int, // num_command_line_args,
    *UnsavedFile, // unsaved_files,
    Int, // num_unsaved_files,
    Int // options
): MutTranslationUnit = clang_parseTranslationUnit;


extern def dispose_translation_unit(MutTranslationUnit): Void = clang_disposeTranslationUnit;

type CXErrorCode  = Int;
const CXError_Success = 0;
const CXError_Failure = 1;
const CXError_Crashed = 2;
const CXError_InvalidArguments = 3;
const CXError_ASTReadError = 4;


def dump_error_code(error: CXErrorCode): Void {
  Debug.dump_string(b"libclang: ");
  if error == CXError_Success {
    Debug.dump_string(b"CXError_Success");
  }
  if error == CXError_Failure {
    Debug.dump_string(b"CXError_Failure");
  }
  if error == CXError_Crashed {
    Debug.dump_string(b"CXError_Crashed");
  }
  if error == CXError_InvalidArguments {
    Debug.dump_string(b"CXError_InvalidArguments");
  }
  if error == CXError_ASTReadError {
    Debug.dump_string(b"CXError_ASTReadError");
  }
}

type CursorKind = Int;

struct Cursor {
  val kind: CursorKind;
  val data: Int;
  val data_0: *Void;
  val data_1: *Void;
  val data_2: *Void;
}

type ChildVisitResult = Int;
// Terminates the cursor traversal.
const CXChildVisit_Break = 0;
   // Continues the cursor traversal with the next sibling of
   // the cursor just visited, without visiting its children.
const CXChildVisit_Continue = 1;
// Recursively traverse the children of this cursor, using
// the same visitor and client data.
const CXChildVisit_Recurse = 2;

type ClientData = *Void;

/// Visitor invoked for each cursor found by a traversal.
///
/// This visitor function will be invoked for each cursor found by
/// clang_visitCursorChildren(). Its first argument is the cursor being
/// visited, its second argument is the parent visitor for that cursor,
/// and its third argument is the client data provided to
/// clang_visitCursorChildren().
///
/// The visitor should return one of the \c CXChildVisitResult values
/// to direct clang_visitCursorChildren().
type CursorVisitor = *(Cursor, Cursor, ClientData) -> ChildVisitResult;

// returns unsigned int; TODO: change to uInt
extern def visit_children(Cursor, CursorVisitor, ClientData): Int = clang_visitChildren;
