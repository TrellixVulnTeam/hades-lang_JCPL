
import libc as c;
import lib.panic as Panic;
import hades.memory as Memory;
import hades.drop as Drop;
import lib.string as String;

const panic = Panic.panic;

struct t {
    val m_buffer: *Byte;
    val m_length: Size;
}

def length(this: t): Size {
    return this.m_length;
}

def _byte_at(this: t, offset: Size): Byte {
    if offset >= this.length() {
        panic(b"String::_byte_at overflow");
    }
    val offset_ptr = this._buffer().offset(offset);
    return *offset_ptr;
}

def _buffer(this: t): *Byte {
    return this.m_buffer;
}

def equals(this: t, that: t): Bool {
    val lengths_not_match = this.length() != that.length();
    if lengths_not_match {
        return false;
    }
    if this._buffer() == that._buffer() {
        return true;
    }
    val mut offset: Size = 0;
    while offset < this.length() {
        if this._byte_at(offset) != that._byte_at(offset) {
            return false;
        }
        offset = offset + 1;
    }
    return true;
}

def as_slice(this: *String.t): t {
    return t(this._buffer(), this.length());
}

